# AWSLambdaServerless

01 서버리스
1.1 서버리스란?

- 서버에서 처리하는 작업을 클라우드 기반의 서비스로 처리하는 것
- 서버를 직접 구축하지 않고 서비스를 사용함으로써 구축 및 관리 비용을 낮추고, 서버 운영에 따라 발생하는 유지보수의 어려움을 줄이기 위해 필요한 순간에만 컴퓨팅 서비스를 제공
  1.2 Cloud Native Patterns
  Legacy
- 인프라부터 애플리케이션까지 구축
  IaaS(Infrastructure as a Service)
- 하드웨어와 가상화, OS등 인프라 요소를 서비스로 제공(AWS EC2)
  CaaS(Container as a Service)
- 서비스 형태로 제공되는 컨테이너를 활용하여 배포(AWS ECS)
  PaaS(Platform as a Service)
- 애플리케이션 개발에 집중할 수 있도록 인프라와 런타인 환경을 제공(AWS Elastic Beanstalk)
  FaaS(Function as a Service)
- 실행할 함수코드만 구현(호출 횟수와 수행시간에 따라 과금)(AWS Lambda)
  SaaS(Software as a Service)
- 제공되는 소프트웨어 사용(Gmail, Dropbox)

  1.3 서버리스의 형태

- BaaS(Backend as a Service)
- 개발자가 직접 구현하던 백엔드의 부분부분을 서비스로 제공받는 것, 예로 AuthO, AWS Cognito같은 인증서비스
- FaaS(Function as a Service)
- 함수를 서비스로 이용하는 것, 서버코드를 실행하기 위해 서버를 구성하고 코드를 배포하던 형식을 줄이고, 원하는 로직만 함수를 기반으로 구현한다.

  1.4 서버리스의 예

- 일반적으로 온프레미스 환경에서는 client > server > database > server > client로 진행. 이는 웹, 응용 프로그램을 구현할 때 사용하는 가장 일반적인 3-Tier구성이다.
- FaaS기반에서는 Client에서 Authentication Service를 호출한 후, 인증을 받고 API Gateway을 호추하여 원하는 함수에 접근. 함수는 호출 즉시 컨테이너에서 실행되며, 호출하지 않을때는 서버가 구동되지 않는다.

  1.5 스케일 아웃, 스케일 업

- 이용자가 증가하거나 확장이 필요할 경우 스케일 아웃 또는 스케일 업 두 가지 방법으로 확장한다.(반대는 스케일 다운, 스케일 인)
- 스케일 아웃: 서버를 여러 대 추가하여 시스템을 확장하는 방법, 각 서버별로 균등하게 부하를 나눠주기 위해 로드밸런서가 필수다.
- 로드밸런서: 네트워크 기술의 일종으로 둘 혹은 셋 이상의 CPU 혹은 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것.
- 스케일 업: 서버가 처리할 수 있는 양을 늘리기 위해 CPU나 RAM등 고성능의 부품으로 업그레이드 하는 것.
- FaaS는 스케일링이 자동화. 함수를 작성할 때 병렬 프로그래밍을 작성하면 서비스 제공자(클라우드 회사)가 이에 맞는 오토 스케일링 처리를 해주고 관리포인트는 줄어든다.

  1.6 서버리스를 토입하면 NoOps인가?

- 관리에는 모니터링, 보안, 네트워크 등이 있고, 필요에 따라 직접 스케일링을 하는 경우가 발생. FaaS가 오토 스케일링이 되지만 한계가 있다. 서비스의 크기가 커질수록 운영이 필요한 시기가 온다.

\*프로비저닝: 사용자의 요구에 맞게 시스템 자원을 할당, 배치, 배포해 두었다가 필요시 시스템을 즉시 사용할 수 있는 상태로 미리 준비해두는 것을 말한다.

1.7 FaaS를 이용하면 서버리스인가?

- 서버리스 아키텍처는 말 그대로 서버리스를 이용한 아키텍처 설계 방식이다.
- 서버리스 아키텍처는 인프라를 관리할 필요 없이 애플리케이션과 서비스를 구추가고 실행하는 방식이다. 애플리케이션은 여전히 서버에서 실행되지만, 모든 서버 관리는 AWS에서 수행한다. 더 이상 애플리케이션, 데이터베이스 및 스토리지 시스템을 실행하기 위해 서버를 프로비저닝, 확장 및 유지 관리할 필요가 없다.

  1.8 서버리스를 사용하는 이유는?
  1.9 서버리는 비싸다?

- 경우에 따라 24시간 구동되는 서버가 더 저렴할 수 있다.

  1.10 FaaS의 단점은?

- 상태유지가 되지 않는다.
- 컨테이너가 잠시 실행되는 환경이다. 즉 상태 비저장을 의미한다. 서버코드로 상태 값을 유지하고, 그 값을 이용하는 로직을 구현하던 방식은 사용할 수 없다. 보완하기 위해 DB를 이용하는 방법이 있다.
- 항상 준비된 상태가 아니다.
- 실행 시 약간의 지연시간이 발생하는데 이를 콜드 스타트라고 한다. 만약 함수를 실행했다면 함수를 실행한 컨테이너는 잠시 대기상태가 되는데 이때 다시 실행하는 것을 웜 스타트라 한다. 이는 준비되어 있어 처음 호출할 때 발생하는 지연시간이 발생하지 않는다.
- 서비스 제공사(클라우드 회사)에 의존적이다.
- AWS기반으로 설계되어 있는 것을 Azure의 환경으로 변경하기 쉽지 않다.

3. 권한관리
   3.1 AWS IAM

- 권한을 관리하는 서비스
- 처음 AWS 계정을 이메일로 생성하면 모든 서비스에 접근할 수 있는 SSO ID가 생성되고 이를 루트권한이라고 한다. 이를 이용하여 유지보수하는 것은 매우 위험하다.
- 사내에서 AWS를 이용하고자 하는 경우에 각자의 부서/팀별로 계정을 생성하여 부여한다. 이때 권한을 세분화하여 Role을 부여함으로써 불필요한 접근을 막을 수 있다.
- 계정 인증에 MFA(Multi Factor Authentication)를 지원한다. 여기서 Factor란 사용자의 신원을 확인하는 방법에 따라 지식, 소유, 속성기반의 인증으로 총 3가지 방법으로 나누어 지는데 이를 인증 팩터라 한다.
- 지식 기반: ID/PW와 같이 알고 있는 인증 정보를 이용한 방법
- 소유 기반: 휴대폰 SMS인증 등 사용자가 소유한 것을 이용하는 방법
- 속성 기반: 고유의 속성을 이용하는 것으로 지문 인식, 홍채 인식 등을 이용하여 인증하는 방법
- MFA를 사용하면 계정 사용자는 작업을 위해 암포 그리고 액세스 키 뿐 아니라 한단계 더 확인 과정을 거친다. 이를 2Factor 인증이라 하며, 두가지의 팩터를 사용해서 인증하는 방식이다.
- IAM에서는 크게 네가지를 구분할 줄 알아야 한다.

1.  IAM User - 사용자
2.  IAM Group - 사용자 그룹
3.  IAM Role - 권한
4.  IAM Policy - 정책

- Policy는 정책을 관리하는 것이다.

  3.2 사용자 계정 생성 및 권한 부여

- 루트 권한의 계정을 사용하기보다는 이에 준하는 권한을 가진 사용자 계정을 생성하여 사용한다.

04 네트워크
4.1 Amazon VPC란

- AWS Lambda는 네트워크 설정을 Amazon VPC(Virtual Private Cloud)로 구성한다.
- VPN(Virtual Private Network)은 가상 사설망이다. 회사의 네트워크를 구성할 때 보안상의 이유로 각각의 권한별 부서별로 접근망을 가상으로 구성한다.
- Amazon VPC는 클라우드 환경에서 구성하는 VPN아리고 생각하면 된다.
- VPC가 없으면 서버들은 서로 복잡하게 거미줄처럼 연결될 것이다.
- VPC별로 네트워크를 구성하고 VPC에 따라 다른 네트워크 설정을 구성할 수 있다. 필요에 따라서는 각각 VPC를 독립된 네트워크처럼 동작할 수 있게 한다.

  4.2 서브넷(Subnet)

- Amazon VPC를 구성하면 서브넷을 구성한다.서브넷은 VPC를 한던 더 나누는 것이다. 서브넷의 주소 범위는 반드시 Amazon VPC IP 주소 범위 이내여야 한다. 즉, 서브넷 IP범위는 VPC IP범위의 부분집합이라고 할수 있다. 서브넷은 실제 리소스가 생성되는 물리적인 공간인 가용영역과 연결된다. VPC가 논리적인 범위를 의미한다면, 서브넷은 VPC안에서 실제로 리소스가 생성되는 네트워크라고 생각할 수 있다.
- 인터넷과 연결이 필요하면 퍼블릭 서브넷을 사용하고, 연결하지 않는 리소는 프라이빗 서브넷을 사용한다. 서브넷은 Amazon VPC보다 더 작은 단위이기에 서브넷 마스크 값이 아이피 범위보다 더 큰값이다.

\*퍼블릭 서브넷의 인스턴스는 인터넷에 바로 아웃바운드 트래픽을 전송할 수 있으며, 외부에서 IP를 통해 인바운드가 가능하다. 프라이빗 서브넷의 인스턴스는 불가능하다.
\*\*프라이빗 서브넷의 인스턴스는 퍼블릭 서브넷에 있는 NAT(Network Address Translation) 게이트웨이를 사용하여 인터넷에 액세스할 수 있다.

4.3 라우팅 테이블(Routing Table)

- 라우팅 테이블은 서브넷과 연결되어 있는 리소스이다. 서브넷에는 네트워크 요청이 있을 때 라우팅 테이블로 접근한다. 라우팅 테이블은 목적지에 대한 이정표이다. 네트워크 요청은 정의된 라우팅 테이블에 따라 움직인다. 문제는 외부로 통하는 길이 없다는 점인데 인터넷 망과 연결을 위해서는 인터넷 게이트웨이가 필요하다.

  4.4 인터넷 게이트웨이(Internet Gateway)

- 인터넷 게이트웨이는 인터넷을 연결해주는 관문이다. Amazon VPC는 격리된 네트워크 환경이라서 생성된 리소들은 인터넷을 연결할 수 없다. 이를 위해 필요한 것이 인터넷 게이트웨이이다.

  4.5 네트워크 ACL(Network Access Control List)

  - 네트워크 ACL은 네트워크 요청을 정해진 규칙에 따라 주고받는 트래픽을 제어하는 가상 방화벽이다. 네트워크 ACL은 다수의 서브넷에서 재사용할 수 있다.

    4.6 보안 그룹(Security Group)

- 보안 그룹은 가상 방화벽 역할을 한다. ACL과의 차이점은 보안 그룹은 인스턴스 앞에서 트래픽을 제어하는 가상 방화벽이고, ACL은 서브넷 앞에서 트래픽을 제어하는 역할이다.
- 인스턴스에 접근하기 전에 앞문의 성격인 ACL과 중문의 성격인 보안 그룹이 있다. Amazon VPC에서는 인스턴스를 시작할 때 최대 5개의 보안 그룹에 인스턴스를 할당할 수 있다.(하나의 인스턴스에 5개까지 보안 그룹을 연결할 수 있는 것이고, VPC내에 보안 그룹은 2500개까지 가능하다.) 보안 그룹은 서브넷이 아닌 인스턴스에서 작동하기에 VPC에 있는 서브넷의 각 인스턴스를 서로 다른 보안 그룹으로 구성할 수 있다.

  4.7 피어링(Peering)

- VPC와 VPC끼리 연결하는데 VPC 피어링을 통해 할 수 있다. 피어링은 프라이빗 IPv4 주소 혹은 IPv6 주소를 이용하여 VPC간에 네트워크 전송을 라우팅한다. 동일한 네트워크에 속하지 않은 VPC의 인스턴스가 서로 통신할 수 있고, 다른 리전에 있는 VPC도 연결이 가능하다.
- 피어링을 사용하면 다른 AWS 리전에서 실행되는 EC2 인스턴스, Lambda 함수 등 같은 VPC 리소스가 게이트웨이, VPN 연결 또는 별도의 네트워크 어플라이언스 없이 프라이빗 IP 주소를 사용하여 서로 통신할 수 있다.

05 AWS Lambda
5.1 AWS Lambda란
-FaaS 서비스이다.

5.2 AWS Lambda의 동작

- 이벤트를 감지하여 아마존 리눅스 환경의 Micro VM을 띄우고 함수를 실행한다. 그리고 결과를 처리한다. 함수가 실행될 때 필요한 환경이 있는데, 이것을 런타임이라고 한다. 런타임은 어떤 언어로 작성하는지에 따라 다르며, 그 환경에 따라 성능 차이가 있다.

- 람다가 실행되면 아마존 리눅스 OS 기반의 Micro VM이 실행된다. 환경 변수 등 실행환경을 맞추고, 지정한 언어별 런타임 환경을 준비한다. 그리고 마지막에 작성한 함수를 실행한다. 이때 람다의 큰 단점이 있다.

  5.3 AWS Lambda의 Cold Start 그리고 Warm Start

- Cold Start가 발생함으로써 딜레이가 존재한다.
- AWS Lambda가 실행되면 당신이 작성한 코드를 다운로드한다. 그리고 실행환경을 구성한다. 이때를 Full cold start라 한다. 런타임을 준비하는 과정은 Partial cold start라고 한다. 마지막으로 함수가 실행될 때 Warn start라고 한다.
- 이처럼 함수가 실행될 때 순서가 정해져 있고 이에 따라 지연시간이 발생한다. Micro VM이 올라갔다가 내려간 뒤 다시 실행하면 Full cold start부터 시작한다. 만약 Micro VM이 유지되는 시간 이전에 재용청하면 Partial cold start가 바로 진행되어 지연시간을 줄일 수 있다.
- cold start를 줄이려면 지속적인 호출을 통해 구동되어 있는 Micro VM을 유지하는 것이다. 보통 5분마다 호출하라고 권고한다.

  5.4 AWS Lambda의 런타임

- AWS Lambda에서는 런타임을 사용하여 각각 다른 언어들로 작성한 코드도 동일한 기본 실행환경에서 실행할 수 있다.
- 함수를 생성할 때 런타임을 선택할 수 있고, 필요시 변경가능하다.
- 런타임 지원이 중단되면 AWS Lambda는 호출을 비활성화 한다. 사용 중단된 런타임은 보안 업데이트 기술지원을 받을 수 없기에 마이그레이션이 필수적이다.

  5.5 AWS Lambda의 Event

- 함수로 서비스를 호출하는 방법은 동기시과 비동기식이 있다.
- 동기
  {
  Elastic Load Balancing(Application Load Balancer),
  Amazon Cognito,
  Amazon Lex,
  Amazon Alexa,
  Amazon API Gateway,
  Amazon CloudFront(Lambda@Edge),
  Amazon Kinesis Data Firehose,
  AWS Step Functions
  }
- 비동기
  {
  Amazon Simple Storage Service,
  Amazon Simple notification Service,
  Amazon Simple Email Service,
  AWS CloudFormation,
  Amazon CloudWatch Logs,
  Amazon CloudWatch Events,
  AWS CodeCommit,
  AWS Config,
  AWS IoT,
  AWS IoT Events,
  AWS CodePipeline
  }
- 동기식은 클라이언트가 람다 함수에 이벤트를 보내고 클라이언트는 함수의 응답을 받을 수 있다. 동기식으로 호출할 경우 파라미터 값을 inkvoke로 실행한다.
- 비동기식은 클라이언트의 요청 이벤트와 람다 함수 사이에 대기열을 이용하는 것이다. 이때 클라이언트는 성공응답만 받는다. 비동기식으로 호출할 경우에는 호출유형 파라미터 값을 Event로 설정해야 한다. 진행할때 오류가 발생하면 계속해서 재시도를 한다.
- 동시성이란 동시에 요청을 처리할 수 있는 함수의 수이다. 이는 리전에 따라 한도가 다른다. 병목현상이 일어날 수 있는 흐름을 예상한다면 동시성의 최대 인스턴스 수를 지정함으로써 안전한 서비스를 유지할 수 있다.

  5.6 메모리 할당과 실행 제한 시간

- AWS Lambda는 메모리와 실행 제한 시간을 직접 설정한다.
- 메모리를 많이 할당할수록 더 빠른 속도를 보인다.
- 상황에 따라서 Amazon EC2같은 인스턴스 서버를 사용하는 것이 더 좋은 선택지가 될 수 있다.
- 람다를 사용하는 목적은 최소의 금액으로 최대의 효과를 본다라는 것을 명심해야 한다.

  5.7 환경 변수

- 환경 변수를 사용하면 함수코드를 배포하지 않고 보안 암호를 저장하고 사용할 수 있다. 키/값 형식으로 저장한다.

  5.8 버저닝(Versioning)

- 함수를 게시할 때마다 새 버전으로 생성되어 히스토리를 남길 수 있다.
- 다만 버전이 저장되면 소스코드에 대한 수정은 불가능하다.

  5.9 테스트

- 함수 테스트를 제공한다. json형식으로 호출한다.

  5.10 계층(Layer)

- 람다는 라이브러리를 패키징하여 계층으로 사용할 수 있다. 공통으로 사용하는 모듈단위가 있다면, 패키징해서 레이어로 재사용할 수 있다는 것이다.
- 레이어를 사용하지 않으면 하나의 함수 용량이 클 수 있으며, 비슷한 용도로 사용되는 함수들에 대해서도 각각의 함수가 허용되는 용량보다 클 수 있다.
- 레이어는 하나의 함수에서 최대 5개를 사용할 수 있다.
- AWS Organizations 지정할 수 있다.

  5.11 태그(Tag)

- 람다는 키-값 형식의 태그를 사용할 수 있다. 태그를 등록하면 특정 함수의 호출빈도 그리고 비용 등 추적 프로세스를 갖출 수 있다.

  5.12 파일 시스템(File System)

- 람다에서 AWS EFS(Elastic File System)을 사용할 수 있게 되었다.
- EFS를 사용하면 기존에 용량 제한이 있었으나 파일 시스템을 사용함으로써 용량에 제한이 없어졌다. 이를 통해 무거운 라이브러리 패키지를 사용하는 것이 가능하게 되었다.

06 스토리지
6.1 AWS S3

- Amazon S3(Simple Storage Service)는 객체 스토리지이다. 안정성이 뛰어나고 가용성이 높으며 무제한 확장이 가능하다. S3를 이해하기 위해 먼저 객체와 버킷을 알아야 한다.
- 객체란 파일과 메타데이터로 이루어진 데이터가 저장되는 기본 단위이다. 메타데이터는 MIME(Multipurpose Internet Mail Extensions) 형식으로 확장자를 통해 자동 설정되고, 사용자가 임의로 지정할 수 있다.
- 버킷이란 S3에서 생성할 수 있는 최상위 디렉토리 이다. 이름과 같은 리전 내에서 유니크해야 하며, 계정별로 100개까지 생성이 가능하다. 객체 수와 용량은 무제한으로 저장할 수 있다.
- 오래전 구축한 파일서버 형태를 탈피하고 S3를 사용하는 추세이다.

\*MIME(Multipurpose Internet Mail Extensions)이란 파일 변환을 뜻한다. 이메일과 함께 동봉할 파일을 텍스트 문자로 전환해서 이메일 시스템을 통해 전달하기 위해 개발되었다. 이 때문에 Internet Mail Extension이 들어간다. 현재는 웹을 통해 여러 형태의 파일을 전달하는 데 쓰이고 있다.

- 넷플릭스가 수십억 시간에 달하는 콘텐츠를 S3를 통해 서비스하고, 에어비엔비는 10페타바이트가 넘는 사용자 사진 그리고 벡업데이터와 정적 파일을 모두 S3에 저장하고 있다.

  6.4 Amazon EFS

- 람다를 이용할 때 EFS를 사용할 수 있게 되었다.
- EFS는 관리형 파일 스토리지이다. 온프레미스 환경에서 사용하던 NFS(Network File System)과 동일한 서비스이다. 필요한 만큼 자동으로 스토리지 공간을 확보한다. 여러 EC2와 동시에 접근이 가능하며 온프레미스 환경의 서버에서도 접근이 가능하다.
- S3와 다르게 EFS는 NFSv4 프로토콜을 통해 파일공유 권한 모델 및 계층 디렉토리 구조를 사용한다. EC2에서 전용 스토리지 볼륨으로 사용하는 EBS(Elastic Block Store)와 EFS는 다른다. EFS는 공유 파일 스토리지이기에 수많은 클라이언트와 동시에 연결하여 사용할 수 있다.
- EFS는 파일시스템, S3는 객체 스토리지, EBS는 블록 스토어이다.

\*NFS는 시스템(Client)에서 다른 시스템(Server)의 자원을 자신의 자원처럼 사용이 가능한 것을 의미한다.

07 메시징 서비스
7.1 Amazon SQS

- Amazon SQS(Simple Queue Service)는 AWS에서 제공하는 안정적인 메시지 큐 서비스이다. 메시지 큐를 먼저 이해해야 한다.

  7.2 메시지 큐

- 메시지 큐의 더 큰 개념으로는 MOM(Message Oriented Middleware)이 있다. MOM은 비동기 메시지를 사용하는 프로그램 간의 데이터 송수신을 의미하는데 MOM을 구현한 시스템을 메시지 큐라고 한다. 메시지 큐는 메시지를 손실없이 정확히 처리하며, 고가용성을 제공한다.오래 걸리는 통신이 있으며, 사용자에게 우선적으로 보여주는 선처리와 비동기 통신을 이요하여 후처리 하는 것이 현대의 애플리케이션 특징인데 이는 가장 대표적인 메시지 전송방법이다. 오픈소스에는 RabbitMQ, ActiveMQ, Kafka등이 있다.
- 메시지 큐의 기본 동작은 Producer->Queue->Consumer이다. Producer가 메시지를 Queue에 넣어두면 Consumer가 메시지를 갖고 온다. 이런 방식을 사용하는 이유는 일반적으로 모든 프로세스를 동기처리하게 되면 사용자가 많이 모이고 그만큼 통신량이 많아지면 병목현상이 생긴다. 그로 인하여 서버 성능이 저하되고, 정상적인 프로세스를 진행 중이던 사용자까지 피해가 발생한다. 이런 문제점을 해결하고자 미들웨어에 메시지를 위임하고 처리하는 방법이다. 일반적으로 사용 방법으로 대용량 데이터 처리를 위한 배치, 채팅 서비스 등이 있다.
- AWS에는 또 다른 메시지큐 서비스로는 Amazon MQ가 있다. 이는 이미 구현하여 동작 중인 애플리케이션을 마이그레이션 하여 바로 사용할 때 사용한다. 또한 AMQP, STOMP, JMS, NMS 등 다양한 표준 프로토콜 호환이 필요할 때 사용한다.
- SQS는 메시지의 보존기간이 있다. 전송에 실패하거나 대기열이 많은 상황이지만 스케일이 처리량에 비해 아주 적을 때 메시지를 보관한다.
- SQS는 FIFO 대기열과 Standard대기열로 직접 구성할 수 있다.
- 표준 대기열은 메시지 순서를 최대한 보존할 수 있으나 2개 이상의 메시지 사본이 순서가 맞지 않게 전송 될 수 있다.
- 선입선출 대기열을 사용하는 목적은 순서가 중요하고 중복항목이 허용되지 않는 경우에 사용한다. FIFO 대기열은 배치작업(Send-Receive-Delete)을 초당(TPS) 최대 3000개의 메시지를 지원한다. 일관 처리(배치성 작업)를 하지 않는다면 초당 300개의 메시지를 지원한다.
- SQS는 최소 1회 전송 처리하는데 만약 전송에 실패하는 경우 이는 중복전송을 할 수 있기에 유의해야 한다. 보존기간은 기본적으로 4일이며, SetQueueAttributes 작업을 통해 60초에서 14일 사이로 초단위 설정을 직접 할 수 있다. 기간이 지나면 메시지를 삭제한다. 이런 특성으로 SQS의 중복 전송은 개발자의 몫이기도 하다.

  7.3 Amazon SNS

- SNS(Simple Notification Service)는 알림을 설정, 운영 및 전송하는 서비스이다. 애플리케이션의 메시지를 게시하면 이를 구독자나 다른 애플리케이션에 즉시 전송할 수 있다.
  7.4 게시-구독(Publish-Subscribe)
- SNS는 Pub-Sub패턴으로 동작한다. 옵저버 패턴이라고 하기도 하는데 비슷한 개념이지만 차이점이 존재한다. 중간에 메시지 브로커 혹은 이벤트 버스의 존재 여부에 따라 구분할 수 있다. 쉽게 말해 옵저버 패턴은 옵저버와 서브젝트가 서로를 인지하지만 Pub-Sub 패턴은 서로를 몰라도 문제 없다. Publisher가 Subscriber의 위치나 존재를 알지 못해도 Message Queue와 같은 Broker역할을 하는 중간지점에 메시지를 던져 놓으면 된다. 하지만 옵저버 패턴은 서브젝트가 직접 옵저버에 알려주어야 한다. 하지만 이러한 차이점에 따라서 결합도가 낮음을 의미하고, 의존성이 낮아 잘못된 구현이 발생할 수 있다.
- Publish가 SNS로 Message를 던지면 토픽을 통해 필러링과 팬아웃을 거치고 구독자에게 전달된다. 토픽이란 애플리케이션 엔드 포인트들이 구독 단위로 그룹핑 되어 있는 것이다.

* 팬 아웃이란 주제 및 그룹을 타겟팅하거나 미리 알림을 전송할 유저들을 구분하고 사용하여 잠재고객 및 사용자에게 여러 기기로 메시지를 전송하는 프로세스이다.

08 API Gateway
8.1 Amazon API Gateway
- 사용자가 쉽게 API를 생성, 게시, 관리, 모니터링, 보안까지 관리가 가능한 완전관리형 서비스이다. 트래픽 관리, CORS지원, 권한 부여 및 액세스 제어, 제한, 모니터링 및 API 버전 관리 등 최대 수십만 개의 동시 API호출을 수신 및 처리하는데 관계된 모든 작업을 처리한다.
- API Gateway는 최소 요금이 존재하지 않는다. 수신한 API호출과 전송한 데이터양에 대한 요금 청구를 받는다. 선택 옵션으로는 RESt api, WebSocket API가 있고, HTTP API까지 존재한다.
8.2 HTTP API
- HTTP는 Hypertext Transfer Protocol의 약자이다. Hypertext Transfer는 링크 기반으로 데이터를 주고받는 것이다. 클라이언트와 서버가 요청과 응담을 하기 위해 따르는 프로토콜이다.
- HTTP의 특성
 1)비연결성(Connectionless)
  - 클라이언트와 서버가 단 한 번의 연결을 통해 정보를 주고받고 서버가 응답을 한번 하면 연결을 끊는다. 장점으로는 연결을 끊음으로써 리소스를 낭비하지 않는다. 단점으로는 매번 새로운 연결을 시도하고 해제하기 때문에 오버헤드가 발생한다. 이를 줄이기 위해 KeepAlive속성을 사용한다. KeepAlive는 지정된 시간 동안 클라이언트와 서버 사이에서 패킷 교환이 없어도 주기적으로 패킷을 보내는것이다. 패킷에 반응이 없으면 접속을 끊는다. 하지만 이는 완벽한 해결방법이 아니다. 서버에서는 메모리를 많이 사용하기때문이다.
  2)무상태(Stateless)
  - 상태가 존재하지 않는다. 이는 상태 값을 갖고 있지 않으며, 요청받은 정보에 대해서 주고받기만 한다.상태를 유지하기 위해서는 클라이언트에서 쿠키를 사용하거나 서버에서 세션을 사용해야 한다. 이때 메모리를 사용하는데 이것은 과부하의 원인이 되기도 하고 위변조의 위험도 존재한다. 토큰을 사용하는 방법도 있다. 대표적으로 OAuth, JWT가 있다.
  3)HTTP Method
  - 클라이언트가 서버로 요청을 할 때 어떠한 목적을 갖는지 HTTP 메소드에 명시한다. GET, HEAD, POST, PUT, PATCH, DELETE, CONNECT, TRACE, OPTION이 있다.
  4)응답 상태코드
  - 서버는 클라이언트 요청에 대해 숫자로 상태코드를 반환한다.

  8.3 REST API
  - REST(Representational State Transfer) 대표적인 상태전달.
  - 우리는 시스템을 구성하는 여러자원이 있다.
  - REST의 특징
  1) 클라이언트/서버
  - REST 서버는 API를 제공하고 이를 클라이언트에서는 사용자 인증이나 컨텍스등을 직접 관리하는 구조가 된다. 이때 각각의 역할이 명확하기에 서로 의존성이 낮아진다.
  2) 무상태
  - 상태가 존재하지 않는다.
  3) 캐싱 처리 가능
  - HTTP를 이용하기 때문에 HTTP프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱을 구현할 수 있다. 캐시를 사용하면 응답시간이 빠르며, 서버의 자원 사용률이 향샹하는 등의 장점이 있다.
  4)계층화
  - 다중 계층으로 구성할 수 있다. 이에 보안, 암호화 계층, 로드벨런싱을 추가하여 구조적으로 유연하게 관리 가능하다. 또한 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있다.
  5)Code-On-Demand
  - 이는 필수적이지 않지만 서버로부터 스크립트를 받아 클라이언트에서 실행하는 것이다.
  6)인터페이스의 일관성
  - REST는 URI로 지정한 자원에 대해 통일하여 한정적인 인터페이스로 수행하는 아키텍쳐 스타일을 의미한다. 쉽게 말해 어떤 서버언어를 사용하는 경우, 그리고 어느 플랫폼을 사용하는지에 따라 영향을 받지 않고 사용할 수 있다.
  
  -인터페이스의 일관성의 제약조건
  1)Identification of resources
   - Resource를 URI로 식별한다.
  2)Manipulation of resources through representations
   - Representations을 전송하여 Resources를 조작한다.(PUT,GET,DELETE...)
  3)Self_Descriptive Messages
  -서버와 클라이언트가 주고받는 메시지가 스스로를 설명해야 한다. 즉, 메시지만으로 어떤 기능인지 이해할 수 있어야 한다.
  -HTTP URI는 자원을, METHOD는 행위를, MIME Type는 표현방식을 의미한다.
  4)Hypermedia as the engine of application state (HATEOAS)
  -애플리케이션의 상태는 하이퍼링크를 이용하여 전이가 되어야 한다. 즉, 리턴 메시지에 링크 값이 있어야 한다.

8.4 HTTP API와 REST API의 선택기준
- 두 개의 서비스는 가격에서 큰 차이가 있다. 

8.5 WebSocket API
- 웹버전의 TCP 또는 Socket을 이용하여 서버와 클라이언트 간 소켓 연결을 통해 양방향 혹은 데이터 전송이 가능한 기술이다. 이전에 기술은 서버와 클라간 영구적인 연결이 아닌 요청과 응답 방식이었다. 그러나 HTML5의 등장으로 우리는 보다 쉽게 소켓 통신을 웹 환경에서 할 수 있게 되었다. HTTP통신과 WebSocket의 차이점은 프로토콜이다. 최초 접속시에는 HTTP를 사용하지만 연결 후 WebSocket의 독자적인 프로토콜로 이루어진다. 실시간 대시보드나 채팅 등에 널리 쓰이고 있다.
